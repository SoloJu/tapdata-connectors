## Custom DML message body instructions

### Input parameter description

1. The record represents the output data from the source and has the following structure

```
record:{
    'data':{
    	//before represents old data, delete and update events have this property, whose value type is key-value pair
    	'before':{
    		key:value
    	},
    	//after means to update data. insert and update events have this property, which is a key-value pair
    	'after':{
    		key:value
    	}
    },
    'eventInfo':{
    	'tableId':'TableName',	// Table name
    	'referenceTime':0,	// Events are generated in milliseconds and are of type Long
    	'XID':'Transaction Id',	// transaction ID generated by the event
    	'rowId':'Record line identification'	// The line identifier generated by the event
    },
}
```

2. op stands for operation type, and there are three operation types: insert, update, and delete
3. conditionKeys a collection of primary key field names that contains all the primary keys

### Return Value Description

1. The returned value represents the structure written to the Kafka message body
2. We can add header and data properties to the return object, where header represents the header part of the kafka message and data represents the body part of the kafka message:

```
customMeesage:{
	// Customize Kafka headers, which contain key/value pairs
	'header':{key:value}
	// Customize Kafka's body
	'data':{
		'tableId':record.eventInfo.tableId,
		'after':record.data.after,
		'rid':record.eventInfo.rowId,
	}
}
```

This return value will add a header with the key op and the value dml to the header of the kafka message.
And write three fields in the body: tableId, after, rid, whose value is the table name of the record, the modified data of the record, and the rowId of the record

3. If the return value is empty, it means that the data is filtered

### Examples

1. Write the XID, rowId, tableId of the dml event, a new field attribute in the script, and the DML data custom into the Body of Kafka, the example code is as follows:

```
// Create a LinkedHashMap object as the body container object
let body = new LinkedHashMap();
// Add custom properties to the body
body.put("XID",record.eventInfo.XID);
body.put("rowId",record.eventInfo.rowId);
body.put("tableId",record.eventInfo.tableId);
body.put("before",record.data.before);
body.put("after",record.data.after);
// Create a LinkedHashMap object as the header container object
let header = new LinkedHashMap();
// Add custom headers to the header
header.put("op","dml");
// Create the return object and add the custom body and header to it
let message = new LinkedHashMap();
message.put("data",body);
message.put("header",header);
return message;
```
