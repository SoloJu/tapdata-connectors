## Custom DML message body instructions

### Input parameter description

#### The record represents the output data from the source and has the following structure

```
record:{
    'data':{
    	//before represents old data, delete and update events have this property, whose value type is key-value pair
    	'before':{
    		key:value
    	},
    	//after means to update data. insert and update events have this property, which is a key-value pair
    	'after':{
    		key:value
    	}
    },
    'eventInfo':{
    	'tableId':'TableName',	// Table name
    	'referenceTime':0,	// Events are generated in milliseconds and are of type Long
    	'XID':'Transaction Id',	// transaction ID generated by the event
    	'rowId':'Record line identification'	// The line identifier generated by the event
    },
}
```

* op stands for operation type, and there are three operation types: insert, update, and delete
* conditionKeys a collection of primary key field names that contains all the primary keys

### Return Value Description

* The returned value represents the structure written to the Kafka message body
* The return value object can have header and data properties, where header represents the header part of the kafka message and data represents the body part of the kafka message

```
customMeesage:{
	// Customize Kafka headers, which contain key/value pairs
	'header':{key:value},
	// Customize Kafka's body
	'data':{key:value}
}
```

* The preceding return value will customize the kafka message body, with headers and data added as key-value pairs
* If the return value is empty, it means that the data is filtered

### Examples

The XID, rowId, and tableId of the dml event, as well as the new tapd field in the script and the DML data customization, are written into the Body of Kafka, as shown in the following example code:

```
// Create a LinkedHashMap object as the body container object
let body = new LinkedHashMap();
// Add custom properties to the body
body.put("XID",record.eventInfo.XID);
body.put("rowId",record.eventInfo.rowId);
body.put("tableId",record.eventInfo.tableId);
body.put("before",record.data.before);
body.put("after",record.data.after);
// Create a LinkedHashMap object as the header container object
let header = new LinkedHashMap();
// Add custom headers to the header
header.put("op","dml");
// Create the return object and add the custom body and header to it
let message = new LinkedHashMap();
message.put("data",body);
message.put("header",header);
return message;
```
